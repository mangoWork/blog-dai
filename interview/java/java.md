## 该部分主要讲解Java面试中的基础知识点

### Java基础的概念

#### 面向对象的三个特征
&nbsp;　**封装**,**继承**,**多态**
&nbsp;　　**封装**：把客观事物封装成为抽象类，隐藏自己的内部实现
&nbsp;　　**继承**：重用父类的代码
&nbsp;　　**多态**：指不同的对象对于同一消息做出不同的相应。

#### 多态的好处
&nbsp;　　允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:
&nbsp;　　1. 可替换性:多态对已存在代码具有可替换性.
&nbsp;　　2. 可扩充性:增加新的子类不影响已经存在的类结构.
&nbsp;　　3. 接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.

##### 代码中如何实现多态
&nbsp;　实现多态主要有以下三种方式:
&nbsp;　　1. 接口实现
&nbsp;　　2. 继承父类重写方法
&nbsp;　　3. 同一类中进行方法重载

##### 虚拟机是如何实现多态的
&nbsp;　　动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.

#### 接口的意义
&nbsp;　接口的意义用三个词就可以概括:**规范**,**扩展**,**回调**。

#### 抽象类的意义
&nbsp;　抽象类的意义可以用三句话来概括:
&nbsp;　　1. 为其他子类提供一个公共的类型
&nbsp;　　2. 封装子类中重复定义的内容
&nbsp;　　3. 定义抽象方法,子类虽然有不同的实现,但是定义时一致的

#### 接口和抽象类的区别

| 比较     | 抽象类                                      | 接口                                  |
| ------ | ---------------------------------------- | ----------------------------------- |
| 默认方法   | 抽象类可以有默认的方法实现                            | ,java 8之前,接口中不存在方法的实现.              |
| 实现方式   | 子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现. | 子类使用implements来实现接口,需要提供接口中所有声明的实现. |
| 构造器    | 抽象类中可以有构造器                               | 接口中不能                               |
| 和正常类区别 | 抽象类不能被实例化                                | 接口则是完全不同的类型                         |
| 访问修饰符  | 抽象方法可以有public,protected和default等修饰       | 接口默认是public,不能使用其他修饰符               |
| 多继承    | 一个子类只能存在一个父类                             | 一个子类可以存在多个接口                        |
| 添加新方法  | 想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码      | 如果往接口中添加新方法,则子类中需要实现该方法.         |

#### 父类的静态方法能否被子类重写
&nbsp;　不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.

#### 什么是不可变对象
&nbsp;　不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。

#### 静态变量和实例变量的区别?
&nbsp;　静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.

#### 能否创建一个包含可变对象的不可变对象?
&nbsp;　当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.

#### java 创建对象的几种方式
1. 采用new
2. 通过反射
3. 采用clone
4. 通过序列化机制

&nbsp;　前2者都需要显式地调用构造方法.   造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.


#### switch中能否使用string做参数
&nbsp;　在jdk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.

#### switch能否作用在byte,long上? 
&nbsp;　可以用在byte上,但是不能用在long上。

-------

### String对象

#### String对象的intern()介绍
 &nbsp;　intern()方法会首先从常量池中查找是否存在该常量值,如果常量池中不存在则现在常量池中创建,如果已经存在则直接返回。
 
 ```shell
 String s1="aa";
 String s2=s1.intern();
 System.out.print(s1==s2);//返回true
 ```

#### String类初始化后是不可变的
&nbsp;　String使用private final char value[]来实现字符串的存储，也就是说String对象创建之后，就不能修改次对象中存储的字符串内容，就是因为如此，String才是不可变的。当使用String的replace等方法修改时，将会创建一个新的对象来实现，而不是对元对象进行修改。

  ![](../img/java/string-edit.png)

#### 引用变量与对象
&nbsp;　``A aa``这个语句声明了类A的引用变量[也叫句柄]，而对象一般通过new 来创建，所以aa只是一个引用变量，而不是对象。

#### 创建字符串的方式
&nbsp;　创建字符串可以分为使用""引号创建字符串以及使用new关键字创建字符串。

&nbsp;　总结：

&nbsp;　　使用”“引号创建的字符串都是常量，编译期间就已经存储在`字符串常量池`中。

&nbsp;　　使用new创建对象的时候对象存储在堆（heap）中，是运行期创建的

&nbsp;　　使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到String Pool中；

&nbsp;　　使用包含变量的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中；


###  使用String不一定创建对象

&nbsp;　　在执行到双引号包含字符串的时候，如String a = “we”，JVM会先到常量池中查找，如果有的话，返回常量池的这个实例中的引用，否则的话创建一个新实例并放在常量池中。

### 使用new String一定创建对象

&nbsp;　　在执行String a = new String("123")的时候，首先走常量池中取得一个实例的引用，然后在堆上面创建一个新的String实例，走以下构造函数给value属性赋值，然后把实例引用赋值给a。

### 关于String.intern()

* intern方法使用：一个初始为空的字符串，它由类String独自维护。当调用intern方法时，如果常量池中已经包含了等于此对象的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。
* 它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 **s.equals(t)** 为 true 时，s.intern() == t.intern() 才为 true。

### 关于equals和==

* 对于==，如果作用于基本数据类型的变量，则比较其存储的“值”是否想等；如果作用域引用变量，则比较的是所指向的对象地址（是否指向同一地址）
* equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。
* 对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。

### String中的+

* String中使用 + 字符串连接符进行字符串连接时，连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符串常量连接起来，形成新的字符串常量参与后续连接（通过反编译工具jd-gui也可以方便的直接看出）；

* 接下来的字符串连接是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创建StringBuilder对象，然后依次对右边进行append操作，最后将StringBuilder对象通过toString()方法转换成String对象（注意：中间的多个字符串常量不会自动拼接）。

  也就是说**String c = "xx" + "yy " + a + "zz" + "mm" + b; 实质上的实现过程是： String c = new StringBuilder("xxyy").append(a).append("zz").append("mm").append(b).toString();**

### String、StringBuffer、StringBuilder

* 可变与不可变：String是**不可变字符串对象**，StringBuilder和StringBuffer是**可变字符串对象**（其内部的字符数组长度可变）。
* 是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然**线程安全**。StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer 中的方法大都采用了synchronized 关键字进行修饰，因此是**线程安全**的，而 StringBuilder 没有这个修饰，可以被认为是**非线程安全**的。
* String、StringBuilder、StringBuffer三者的执行效率：
  StringBuilder > StringBuffer > String 当然这个是相对的，不一定在所有情况下都是这样。比如String str = "hello"+ "world"的效率就比 StringBuilder st  = new StringBuilder().append("hello").append("world")要高。因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：
  * 当字符串相加操作或者改动较少的情况下，建议使用 String str="hello"这种形式；
  * 当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。

### **关于String str = new String("abc")创建了多少个对象？**

* 在**类加载的过程**中，确实在运行时常量池中创建了一个"abc"对象，而在**代码执行过程中**确实只创建了一个String对象。

### String s1="ab",String s2="a"+"b",String s3="a",String s4="b",s5=s3+s4请问s5==s2返回什么?

 返回false.在编译过程中,编译器会将s2直接优化为"ab",会将其放置在常量池当中,s5则是被创建在堆区,相当于s5=new String("ab");
