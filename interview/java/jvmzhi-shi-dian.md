### JVM常见的面试的基础点
#### JVM特性

&nbsp;　　平台无关性.

&nbsp;　　Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

#### 简单解释一下类加载器

&nbsp;　　有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,更多的内容参看深入理解JVM加载器

#### 简述堆和栈的区别

&nbsp;　　VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

#### 简述JVM内存分配

    1. 基本数据类型比变量和对象的引用都是在栈分配的
    
    2. 堆内存用来存放由new创建的对象和数组
    
    3. 类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中
    
    4. 实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的"物理位置”,实例变量的生命周期--当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存
    
    5. 局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放

#### 对象在内存中的布局、对象的创建、以及对象的访问

&nbsp;　1.对象的内存布局：

&nbsp;　　1.1 对象在内存中的布局可以分为三块区域：对象头、实例数据、和对齐填充

&nbsp;　　1.2 对象头包括两部分信息（如果是数组，则还有一部分用于记录数组长度的数据）：

&nbsp;　　　1.2.1 第一部分信息用于存储自身的运行时数据，比如哈希吗（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的ID、偏向时间戳等等，这部分数据在32位和63位虚拟机中分别为32个和64个字节，官网称为“Mark Word”

&nbsp;　　　1.2.2 另一部分是类型指针，即是对象指向它的类的元数据指针。虚拟机通过这个指针来确定这个对象是那个类的实例。
    
&nbsp;　2.对象的创建：

&nbsp;　　2.1 当虚拟机遇到new指令时，首先检查这个指令的参数能否在常量池中定位到这个类的符号引用，并检查这个类是否已经被加载、解析、初始化。如果没有则必须进行类的加载过程。

&nbsp;　　2.2 为新生对象分配内存，通过指针碰撞或者空闲列表法。为了解决并发问题可以采用TLAB本地线程分配缓冲策略。
  
&nbsp;　3.对象访问定位：
&nbsp;　　3.1 使用句柄和直接指针两种方式。（句柄：Object引用是一个句柄，其中包含一对指针，一个指针指向该object方法表，一个指向object的数据）

#### JVM内存模型

&nbsp;　1. 内存模型：内存模型描述了各个变量（实例域＼静态域和数组元素）之间的联系，以及在实际的计算机系统中将变量存储到内存以及从内存中取出变量这样的底层细节。

&nbsp;　2.线程私有：程序计数器、虚拟机栈、本地方法栈。

&nbsp;　3.线程共享：堆、方法区

&nbsp;　4.虚拟机栈：Java方法执行的内存模型，每一个Java方法在执行的时候都会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。

&nbsp;　　4.1 局部变量表存放在编译期可知的基本类型和引用类型，局部变量所需你的内存空间在编译期间分配完成，运行期间不会改变大小。

&nbsp;　　4.2 操作数栈中存放指令执行时所需的操作数。

&nbsp;　　4.3 动态链接：每个栈帧中都包含一个该栈帧所属的方法引用。

&nbsp;　　4.4 方法出口：每一个方法结束无非是正常return或者抛出了Exception并没有catch语句，在方法执行完之后需要返回到方法调用的位置，返回时需要在栈帧中保存一些信息，用来恢复他的上层方法的执行状态。可能抛出StackOverflowError或者OutOfMemoryError

&nbsp;　5.本地方法栈：为native方法服务。可能抛出StackOverFlowError或OutOfMemoryError。

&nbsp;　6.堆：虚拟机管理内存中的最大的一块，在虚拟机启动的时候创建，用于存放实例和数组，从垃圾回收的角度分为新生代、老年代；在细分可以分为Eden、From Survivor、To Survivor空间、老年代。可能出现OutOfMemeryError。

&nbsp;　7.方法区：用来存储虚拟息、常量、静机加载的类的信态变量、即使编译后的代码数据。垃圾回收的对象为：常量池的回收和类型的卸载。可能出现OutOfMenoryError。

#### 类的加载过程

&nbsp;　1. 以被初始化的六种情况：
&nbsp;　　 1.1 创建类的实例
&nbsp;　　 1.2 访问某个类或者接口的静态变量，或者对该静态变量赋值
&nbsp;　　 1.3 调用类的静态方法
&nbsp;　　 1.4 反射，如（Class.ForName(“com.dai....”)）
&nbsp;　　 1.5 初始化一个类的子类
&nbsp;　　 1.6 Java虚拟机启动时被标为启动的类

&nbsp;　2.类的加载过程

&nbsp;　　 2.1 加载-->连接（验证-->准备-->解析）-->初始化

&nbsp;　　 2.2 加载：类的加载时将类的.class文件中的二进制数据存放到内存中，将其存放在运行时数据区内，然后在堆区创建一个java.lang.Class对象，用来封装在方法中的数据结构。

&nbsp;　　 2.3 验证：确保class文件中的字节流中的信息符合当前虚拟机的要求，包括：文件格式验证、元数据验证、字节码验证、符号引用验证。

&nbsp;　　 2.4 准备:  为类变量分配内存，并设置类变量初始零值。

&nbsp;　　 2.5 解析：将常量池中的符号引用替换为直接引用。这一阶段会根据实际的需求发生在初始化之前或之后，包含类或者接口的解析、字段解析、方法解析。（符号引用是无关虚拟机的内存布局。直接引用是和虚拟机相关的内存布局相关的。符号引用必须在运行期转换获得真正的入口地址）

&nbsp;　　 2.6 初始化：执行clinit方法，该方法由编译器自动按书写顺序收集类中所有的类变量的赋值动作和静态语句块中的语句合并而成。
  
&nbsp;　3.对象的创建的执行顺序：

&nbsp;　　3.1 父类静态，子类静态、父类成员域、父类代码块、父类构造方法、子类成员域、子类代码块、子类构造方法

#### 双亲委派模型

&nbsp;　1.类加载器通过组合的方式建立的父子关系，称为双亲委派模型

&nbsp;　2.类加载器：
&nbsp;　　2.1 Bootstrap ClassLoader:负责加载JAVA_HOME/lib目录，或者被XboostrapPath参数所指定的路径指定的类库。
  
&nbsp;　　2.2 Extension ClassLoader:负责加载JAVA_HOME/lib/ext目录，或者被java.ext.dir系统变量所指定的路径所指定的类库。
  
&nbsp;　　2.3 ApplicationClassLoader：是ClassLoader.getSystemClassLoader()方法的返回值，负责架子啊用户类路径上所指定的类库。

&nbsp;　3.工作过程：

&nbsp;　　3.1 一个类加载器收到类加载的请求，它首先不会尝试自己加载这个类而是把这个请求委托给父类去加载去完成。只有当父加载器反馈自己无法完成这个请求时，自加载器才会自己去加载。

&nbsp;　4.作用:

&nbsp;　　4.1 Java随着它的类加载器一起具备了一种优先级的层级关系，比如Object这个类，无论哪个类加载器他最终都会委派到bootstrapClassLoader去加载。保证了Java程序的稳定执行。

#### 静态分派与动态分派

&nbsp;　1.静态分派
&nbsp;　　1.1 依赖静态类型来定位方法执行版本的分派动作称为静态分派（根据静态参数来定位目标方法），典型的应用为overload。静态分派发生在编译阶段，因此静态分配的动作实际上不是由虚拟机执行的。

&nbsp;　2.动态分派：
&nbsp;　　2.1 根据运行期间实际类型来确定方法的引用，典型的应用为override。

#### GC的两种判定方法

&nbsp;　1.引用计数法：在对象中添加一个引用计数器，每一个地方引用它值加1，当引用失效时减1。这种方法很难解决对象间互相循环的引用的问题。

&nbsp;　2.可达性分析算法:

&nbsp;　　2.1 选一个对象为GC Roots,如果一个对象gc不可达，那么就回收。

&nbsp;　　2.2 选作GC Roots对象包括下面几种：

&nbsp;　　　2.2.1 虚拟机栈中引用的对象；

&nbsp;　　　2.2.2 方法区类静态属性引用的对象；

&nbsp;　　　2.2.3 方法区常量引用对象；

&nbsp;　　　2.2.4 本地方法栈中引用的对象

&nbsp;　3.如果一个对象与GC ROOTS不可达时，将会被第一次标记并筛选判断是否有必要执行finalize()方法，有必要执行的进入F-QUEUE队列，稍后虚拟机将自动建立一个低优先级的线程去执行它。稍后虚拟机将进行二次标记：在finalize()方法中建立了与GC ROOTS的通路，仍然可以存活。

#### Java的引用类型

&nbsp;　1.强引用类型：强引用类型就是平常使用的A a=new A();如果一个对象是强引用类型，垃圾回收器绝不会回收。当内存空间不足的时候宁愿抛出outofmemoryError是程序终止，也不会随意回收来解决对象内存不足的问题。

&nbsp;　2.软引用类型：如果一个对象只具有软引用，如果内存空间足够，垃圾回收器不会回收它；如果内存空间不足时，则回收它。一般用来缓存。使用软引用可以构建敏感数据的缓存.

&nbsp;　　2.1代码示列：
      ```java
        MyObject obj = new MyObject();  
        ReferenceQueue<MyObject> refQue = new ReferenceQueue<MyObject>();  // 使用ReferenceQueue清除失去了软引用对象的SoftReference
        SoftReference<MyObject> ref = new SoftReference<MyObject>(obj, refQue);  //SoftReference 软引用的对象  
        obj = null;// 清除对象的强引用
        Myobject obj1 = ref.get();// 如果在内存中没有被回收将会获得实例的引用，如果回收之后，调用get()方法就只能返回null
      ```
    
&nbsp;　3.弱引用类型：只具有弱引用的对象用友更短暂的生命周期。当垃圾回收器扫描内存区域的时候，如果发现了弱引用对象，不管内存空间是否足够，都会回收它的内存。如WeakHashMap,它的key被封装成弱引用，当强引用被删除的时候，弱引用占用的内存也会被回收。

&nbsp;　4.虚引用类型：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它和没有任何引用一样，可以在任何时候被被垃圾回收器回收。

&nbsp;　5.为什么需要使用软引用？
&nbsp;　　5.1 如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度

#### 堆里面的分区：Eden、Survival from to以及老年代的各自特点

&nbsp;　1.Eden区：

&nbsp;　　1.1 位于Java堆新生代。（新生代中的寿命比较短）大多数情况下，对象由Eden区分配，如果启动了TLAB（本地线程分配缓冲），则优先在TLAB中分配。如果Eden区中的内存也是用完了，则引发一次Minor GC。

&nbsp;　2.Survival区：

&nbsp;　　2.1 Survival区和Eden区相同都在Java堆的新生代。Survival有两块区：一块是Survival to区，另外一块是Survival from区。这两个区是相对的，在发生一次Minor GC时，from区会和to区互换。在发生Mimor GC时，Survival to区会把一些存活的对象移至老年代，Eden区和Survival from 区会把一些存活的对象复制进Survival to区，并清除内存。

&nbsp;　3.老年代：

&nbsp;　　3.1 老年代存放的都是存活比较久，大小比较大的对象，因此老年代使用标记整理算法。当老年代容量满时，会触发一次Major GC（full GC），回收老年代和新生代中不在使用的对象。


#### 常用的三种垃圾回收算法（标记清除，标记整理，复制算法）：

&nbsp;　1.标记清除：

&nbsp;　　1.1 标记清除算法分为两个步骤执行： 1.暂停用户线程，通过GC Roots可达性分析算法标记对象。2.清除未被标记的垃圾对象。

&nbsp;　　1.2 缺点：

&nbsp;　　1.2.1 效率低，需要暂停用户的线程。

&nbsp;　　1.2.2 清除垃圾对象后内存不连续，存在较多的内存碎片。（这种算法使用比较少了）

&nbsp;　2.复制算法：
&nbsp;　　2.1 赋值算法也分两步执行，在复制算法中一般会有至少两片的内存空间（一片是活动空间，里面存放各种对象，另一片是空闲空间，里面是空的）：

&nbsp;　　2.2 暂停用户线程，标记活动空间的存活对象。

&nbsp;　　2.3 把活动空间中存活对象复制到空闲空间中，清除活动空间。

&nbsp;　　2.4 复制算法相比于标记清除发的优势在与内存是连续的。

&nbsp;　　2.5 缺点：

&nbsp;　　2.5.1 需要浪费一定的内存空间作为空闲空间。

&nbsp;　　2.5.2 如果对象的存活率很高，需要复制大量的对象，则会导致效率低下。

&nbsp;　　2.6 复制算法一般用于新生代Minor GC，主要因为新生代对象存活率较低。

&nbsp;　3.标记整理：

&nbsp;　　3.1标记整理算法是标记清除算法的改进，分为标记，整理两步：

&nbsp;　　3.1.1暂停用户线程，标记所有存活的对象

&nbsp;　　3.1.2 移动所有存活的对象，按内存地址一次排序，回收末端以后的内存空间

&nbsp;　　3.2标记整理法与标记清除法相比，整理出的内存是连续的；而与复制法相比不需要多片内存空间。

&nbsp;　　3.3缺点：
&nbsp;　　3.3.1然而标记整理法的第二部比较繁琐，需要整理存活的引用地址，理论上说是效率低于复制法，因此用于Major GC(full GC)

#### Minor GC和full GC触发的机制

&nbsp;　1.Minor GC(新生代GC)：

&nbsp;　　1.1大多数情况，对象在新生代Eden区中分配，当Eden区中没有足够的空间，虚拟机触发一次Minor   GC。Minor GC非常频繁、速度快。

&nbsp;　2.Full GC（老年代GC）：

&nbsp;　　2.1在Minor GC之前会先检查老年代中最大可用连续空间是否大于新生代中的对象，如果成立，则这次Minor GC是安全的。否则就要查看是否允许担保失败，如果不允许则改为进行Full GC,允许的话就尝试进行一次Minor GC；

&nbsp;　　2.2此外当年老代容量满的时候，也会触发一次full GC
