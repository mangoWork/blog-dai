#### Kafka基础知识

##### Kafka的优势


&nbsp;　　构建实时的流数据管道，可靠地获取系统和应用程序之间的数据。

&nbsp;　　构建实时流的应用程序，对数据流进行转换或反应。


##### Kafka所使用的基本术语：

**Topic**

> Kafka将消息分门别类，每一类的消息称之为一个主题\(Topic\)

**Producer**

> 发布消息的对象称之为生产者

**Consumer**

> 订阅消息并处理发布的消息的对象称之为消费者

**Broker**

> 已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理\(Broker\)。消费者可以订阅一个或者多个主题\(Topic\),并从Broker拉数据，从而消费这些已发布的消息。

##### 主题和日志\(Topic和Log\)

&nbsp;　　Topic是发布的消息的类别。对于每一个Topic，Kafka集群维护着一个分区的log，如下图所示：

![](/bigdata/kafka/img/topic1.png)


&nbsp;　　每一个分区都是一个顺序的、不可变的消息队列，并且可以持续添加。分区中的消息都被分了一个序列号，称之为**偏移量\(offset\)**，在每隔分区中此偏移量都是唯一的。

&nbsp;　　Kafka集群保持所有的信息，直到它们过期，无论消息是否被消费了。实际上消费者所持有的仅有的元数据就是这个偏移量，也就是消费者在这个log中的位置。 这个偏移量由消费者控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更老的一个偏移量，重新读取消息。并且一个消费者的操作不会影响其它消费者对此log的处理。

&nbsp;　　Kafka分区的目的：一是可以处理更多的消息，不受单台服务器的限制，Topic拥有更多分区也就意味着它可以不受限的处理更多的数据。第二，分区可以作为并行处理的单元。

##### 分布式
&nbsp;　　log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。

作者：半兽人
链接：http://orchome.com/5
来源：OrcHome
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 生产者(Producers)
&nbsp;　　生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。


##### 消费者(Consumers)

&nbsp;　　通常来讲，消息模型可以分为两种， **队列**和**发布-订阅式**。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。
&nbsp;　　Kafka为这两种模型提供了单一的消费者抽象模型： **消费者组 （consumer group）**。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：
![](./img/kafkacluster.png)

&nbsp;　　2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个

